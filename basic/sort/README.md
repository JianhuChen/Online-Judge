## 排序算法及相关题目

- 选择排序 O(N^2) O(1)

- 冒泡排序 O(N^2) O(1)

- 插入排序 O(N^2) O(1)

- 归并排序 O(nlog(N)) O(N)  (Master公式求解时间复杂度, a=2, b=2, d=1)

  - [小和问题](small_sum.py)

  - [逆序对个数](reverse_pair.py)

  - [比右侧大两倍的数](bigger_than_right_twice.py)

  - [区间和的个数](count_range_sum.py)

- 快速排序 O(nlog(N)) O(1)

  - [荷兰国旗问题, 荷兰国旗问题v2](netherlands_flag.py)

  - [快速排序v1, v2, v3](sort.py)

- 堆排序 O(nlog(N)) O(1)

  - [堆结构](heap.py)
    - 是一棵完全二叉树
    - 任何一棵子树的根节点的值都大于或等于其左右子树的值

  - [几乎有序的数组排序](sort_array_distance_less_k.py)

  - [数据流的中位数](find_median_from_data_stream.py) 

  - [逆序栈](reverse_stack.py)

- 希尔排序 O(N^1.3) O(1)

以上均是基于比较的排序算法, 除此之外, 还有一些不是比较的排序算法, 如:

- 计数排序

- 基数排序

## 排序算法总结

| 算法名称 | 时间复杂度 | 空间复杂度 | 稳定性 |
| :------- | :--------: | :--------: | :----: |
| 选择排序 |   O(N^2)   |    O(1)    |   ❌    |
| 冒泡排序 |   O(N^2)   |    O(1)    |   ✅    |
| 插入排序 |   O(N^2)   |    O(1)    |   ✅    |
| 归并排序 | O(Nlog(N)) |    O(N)    |   ✅    |
| 快速排序 | O(Nlog(N)) | O(log(N))  |   ❌    |
| 堆排序   | O(Nlog(N)) |    O(1)    |   ❌    |
| 希尔排序 |  O(N^1.3)  |    O(1)    |   ❌    |


## 二分相关题目

- [有序数组中找到num](bianry_search.py)

- [有序数组中找到>=num最左的位置](bianry_search.py)

- [有序数组中找到<=num最右的位置](bianry_search.py)

- [局部最小值问题](bianry_search.py)

  定义何为局部最小值:
  - arr[0] < arr[1], 0位置是局部最小
  - arr[N-1] < arr[N-2], N-1位置是局部最小
  - arr[i-1] > arr[i] < arr[i+1], i位置是局部最小
  - 给定一个数组arr(可能无序), 已知任何两个相邻的数都不相等, 找到随便一个局部最小位置返回

## 工程优化

- 在不要求稳定性的情况下, 可以使用快速排序 (时间复杂度 O(Nlog(N)), 且常数级空间复杂度较小)
- 要求稳定性的情况下, 可以使用归并排序 (时间复杂度 O(Nlog(N)))
- 空间复杂度要求 O(1) 的情况下, 可以使用堆排序 时间复杂度 O(Nlog(N)))

> 一般标准库中的做法:
> 
> - 当对数值类型进行排序时: 使用快排 (全局使用快排进行调度) + 插入排序 (当元素个数小于一定的阈值时使用插入排序)
> - 当对自定义类型进行排序时: 使用归并排序 (尽可能快的同时保证稳定性) + 插入排序
